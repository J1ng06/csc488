/*
    DEFINITIONS for CSC488S Source Language Winter 2016
*/

package compiler488.parser;

import compiler488.ast.*;
import compiler488.ast.Readable;
import compiler488.ast.stmt.*;
import compiler488.ast.expn.*;
import compiler488.ast.decl.*;
import compiler488.ast.type.*;

// TODO: You can add Java import statements here as necessary

/*
    SYMBOL LISTS

    CUP reserved words are case-sensitive and cannot be used as names of
    terminals or non-terminals. This list includes the following:

        action code extends import init left non nonassoc nonterminal package
        parser precedence right scan start super terminal with

*/

// Keyword terminals returned by the scanner (with no value attached):
terminal AND, OR, NOT, TRUE, FALSE;
terminal BOOLEAN, INTEGER, FUNCTION, PROCEDURE;
terminal DO, ELSE, EXIT, IF;
terminal READ, REPEAT, RETURN, NEWLINE, THEN, UNTIL;
terminal VAR, WHEN, WHILE, WITH, WRITE;

// Special-character terminals (with no value attached):
terminal L_PAREN, R_PAREN, L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY;
terminal EQUAL, GREATER, LESS, COMMA, DOT, QUESTION, COLON;
terminal PLUS, MINUS, TIMES, DIVIDE;

// Terminals returned by the scanner that carry a value of a specific Java type:
terminal String     IDENT;
terminal Integer    INTCONST;
terminal String     TEXTCONST;

/*
    To define non-terminals that return no value:

        nonterminal nameList;

    To define non-terminals that do return a value (think AST generation):

        nonterminal JavaType nameList;
*/

 
nonterminal Program program;
nonterminal Stmt statement;
nonterminal Declaration declaration;
nonterminal Scope scope;
nonterminal ASTList<Stmt> statements;
nonterminal ASTList<Declaration> declarations;
nonterminal Stmt matchedStatement;
nonterminal Stmt unmatchedStatement;
nonterminal ASTList<DeclarationPart> variablenames;
nonterminal Printable output;
nonterminal Type type;
nonterminal ASTList<Expn> arguments;
nonterminal ASTList<ScalarDecl> parameters;
nonterminal Expn variable;
nonterminal Expn expression;
nonterminal DeclarationPart variablename;
nonterminal ASTList<Readable> inputs;
nonterminal ASTList<Printable> outputs;
nonterminal ArrayBoundPart bound;
nonterminal Integer generalBound;
nonterminal Stmt procedureCall;
nonterminal ScalarDecl parameter;
nonterminal Expn conjunction;
nonterminal Expn negation;
nonterminal Expn compareExpn;
nonterminal Expn arithExpn;
nonterminal Expn term;
nonterminal Expn factor;
nonterminal Expn primary;
nonterminal ConstExpn constant;
 

/*
    PLEASE NOTE: Your grammar may not use the 'precedence' feature of JCup to
    resolve the precedence of arithmetic operators.

    The two lines below must remain commented out;
*/

// precedence left PLUS, MINUS;
// precedence left TIMES, DIVIDE; // Higher precedence.

//  Use precedence to associate else with closest if
precedence left ELSE;

/*
    GRAMMAR SECTION
*/

// This specifies the initial symbol of the grammar.
start with program;

/*
    Notice that sometimes the action must be inside the production rule, not after
    it. This is a subtle yet significant difference from YACC. This is because the
    CUP parser is looking ahead one token. It ALWAYS reads one more token before it
    will act on the production.
 */

program ::= scope:s		{: RESULT = new Program(s); :}                           // the main program
    ;

scope
    ::= L_CURLEY declarations:decl statements:stmt R_CURLEY   	{: RESULT = new Scope((ASTList<Declaration>) decl, (ASTList<Stmt>) stmt); :} // scope with declarations and statements
    |   L_CURLEY statements:stmt R_CURLEY                {: RESULT = new Scope(); RESULT.setStatements(stmt); :} // scope with statements only
    |   L_CURLEY R_CURLEY                           {: RESULT = new Scope(); :} // empty scope
    ;

statements
    ::= statement:stmt                       {: RESULT = new ASTList<Stmt>(stmt); :}// sequence of statements
    |   statements:list statement:stmt				{: RESULT = list.append(stmt); :}
    ;

declarations
    ::= declaration:decl                     {: RESULT = new ASTList<Declaration>(decl); :}// sequence of declarations
    |   declarations:list declaration:decl	{: RESULT = list.append(decl); :}
    ;

statement
    ::= matchedStatement:ms		{: RESULT = ms; :}
    |   unmatchedStatement:us	{: RESULT = us; :}
    ;

matchedStatement
    ::= variable:var COLON EQUAL expression:expn                             {: RESULT = new AssignStmt(var, expn); :}// assignment statement
    |   IF expression:cond THEN matchedStatement:ifTrue ELSE matchedStatement:ifFalse   {: RESULT = new IfStmt(cond, ifTrue, ifFalse); :}// if statements
    |   WHILE expression:cond DO statement:body                               {: RESULT = new WhileDoStmt(cond, new ASTList<Stmt>(body)); :}// while statement
    |   REPEAT statements:body UNTIL expression:cond                           {:RESULT = new RepeatUntilStmt(cond, body); :}// repeat statement
    |   EXIT                                                        {: RESULT = new ExitStmt(new BoolConstExpn(true), 1); :}// exit statements
    |   EXIT INTCONST:levels												{: RESULT = new ExitStmt(new BoolConstExpn(true), levels); :}
    |   EXIT WHEN expression:cond									{: RESULT = new ExitStmt(cond, 1); :}
    |   EXIT INTCONST:levels WHEN expression:cond					{: RESULT = new ExitStmt(cond, levels); :}
    |   RETURN WITH expression:retval										{: RESULT = new ReturnStmt(retval); :}
    |   RETURN                                                      {: RESULT = new ReturnStmt(null); :}// return statements
    |   WRITE outputs:list                                               {: RESULT = new WriteStmt(list); :}// input/output statements
    |   READ inputs:list											{: RESULT = new ReadStmt(list); :}
    |   procedureCall:pc                                               {: RESULT = pc; :}// procedure call
    |   scope:s                                                       {: RESULT = s; :}// embedded scope
    ;

unmatchedStatement
    ::= IF expression:cond THEN statement:ifTrue								{: RESULT = new IfStmt(cond, ifTrue); :}
    |   IF expression:cond THEN matchedStatement:ifTrue ELSE unmatchedStatement:ifFalse				{: RESULT = new IfStmt(cond, ifTrue, ifFalse); :}
    ;

procedureCall
    ::= IDENT:name                                       {: RESULT = new ProcedureCallStmt(name, new ASTList<Expn>());:}// call procedure with no parameters
    |   IDENT:name L_PAREN arguments:args R_PAREN         {: RESULT = new ProcedureCallStmt(name, args); :}   // call procedure with parameters
    ;

declaration
    ::= VAR variablenames:varnamelist COLON type:type                               {: RESULT = new MultiDeclarations(type, varnamelist); :} // declare scalar/array variables
    | FUNCTION IDENT:name COLON type:type scope:body                               {: RESULT = new RoutineDecl(name, type, body); :}// declare function
    | FUNCTION IDENT:name L_PAREN parameters:params R_PAREN COLON type:type scope:body		{: RESULT = new RoutineDecl(name, type, params, body); :}
    | PROCEDURE IDENT:name scope:body                                         {: RESULT = new RoutineDecl(name, body); :}// declare procedure
    | PROCEDURE IDENT:name L_PAREN parameters:params R_PAREN scope:body					{: RESULT = new RoutineDecl(name, params, body); :}
    ;

variablenames
    ::= variablename:varname                                {: RESULT = new ASTList<DeclarationPart>(varname); :}// list of variables being declared
    |   variablenames:list COMMA variablename:varname					{: RESULT = list.append(varname); :}
    ;

variablename
    ::= IDENT:name                                       {: RESULT = new ScalarDeclPart(name); :}// scalar variable
    |   IDENT:name L_SQUARE bound:b R_SQUARE               {: RESULT = new ArrayDeclPart(name, b.getLb(), b.getUb()); :}// 1-dimension array variable
    |   IDENT:name L_SQUARE bound:b1 COMMA bound:b2 R_SQUARE   {: RESULT = new ArrayDeclPart(name, b1.getLb(), b1.getUb(), b2.getLb(), b2.getUb()); :}// 2-dimensional array variable
    ;

bound
    ::= INTCONST:ic                                    {: RESULT = new ArrayBoundPart(1, ic); :}// positive array bound
    |   generalBound:gb1 DOT DOT generalBound:gb2         {: RESULT = new ArrayBoundPart(gb1, gb2); :}  // upper and lower bounds
    ;

generalBound
    ::= INTCONST:ic                    {: RESULT = ic; :}// positive integer bounds
    |   MINUS INTCONST:ic              {: RESULT = -ic; :}// negative integer bounds
    ;

type
    ::= INTEGER                     // integer type
    |   BOOLEAN                     // boolean type
    ;

outputs
    ::= output:out                      {: RESULT = new ASTList<Printable>(out); :}// list of output expressions
    |   outputs:list COMMA output:out		{: RESULT = list.append(out); :}
    ;

output
    ::= expression:expn                  {: RESULT = expn; :}// integer expression
    |   TEXTCONST:tc                   {: RESULT = new PrintableStr(tc); :}// text constant
    |   NEWLINE                     {: RESULT = new PrintableStr("\n"); :}// newline constant
    ;

inputs
    ::= variable:var                    {: RESULT = new ASTList<Readable>(new ReadableExpn(var)); :}// list of variables being read into
    |   inputs:list COMMA variable:var	{: RESULT = list.append(new ReadableExpn(var)); :}
    ;

arguments
    ::= expression:expn                  {: RESULT = new ASTList<Expn>(expn); :}// list of function/procedure arguments
    |   arguments:list COMMA expression:expn		{: RESULT = list.append(expn); :}
    ;

parameters
    ::= parameter:param                   {: RESULT = new ASTList<ScalarDecl>(param); :}// list of function/procedure formal parameters
    |   parameters:list COMMA parameter:param		{: RESULT = list.append(param); :}
    ;

parameter
    ::= IDENT:name COLON type:t            {: RESULT = new ScalarDecl(name, t); :}// declare one parameter
    ;

expression
    ::= conjunction:c                 {: RESULT = c; :}// disjunctions, associate left-to-right
    |   expression:e OR conjunction:c	{: RESULT = new BoolExpn("or", e, c); :}
    ;

conjunction
    ::= negation:n                    {: RESULT = n; :}// conjunctions, associate left-to-right
    |   conjunction:c AND negation:n	{: RESULT = new BoolExpn("and", c, n); :}
    ;

negation
    ::= compareExpn:ce                 {: RESULT = ce; :}// negations
    |   NOT negation:n					{: RESULT = new NotExpn(n); :}
    ;

compareExpn
    ::= arithExpn:ae                                   {: RESULT = ae; :}// comparisons, do not associate
    |   arithExpn:ae1 EQUAL arithExpn:ae2				{: RESULT = new EqualsExpn("=", ae1, ae2); :}
    |   arithExpn:ae1 NOT EQUAL arithExpn:ae2			{: RESULT = new EqualsExpn("not =", ae1, ae2); :}
    |   arithExpn:ae1 LESS arithExpn:ae2					{: RESULT = new CompareExpn("<", ae1, ae2); :}
    |   arithExpn:ae1 LESS EQUAL arithExpn:ae2				{: RESULT = new CompareExpn("<=", ae1, ae2); :}
    |   arithExpn:ae1 GREATER arithExpn:ae2						{: RESULT = new CompareExpn(">", ae1, ae2); :}
    |   arithExpn:ae1 GREATER EQUAL arithExpn:ae2				{: RESULT = new CompareExpn(">=", ae1, ae2); :}
    ;

arithExpn
    ::= term:t                        {: RESULT = t; :}// expressions, associate + , - left-to-right
    |   arithExpn PLUS term
    |   arithExpn MINUS term
    ;

term
    ::= factor:f                      {: RESULT = f; :}// terms, associate * , / left-to-right
    |   term:t TIMES factor:f			{: RESULT = new ArithExpn("*", t, f); :}	
    |   term:t DIVIDE factor:f				{: RESULT = new ArithExpn("/", t, f); :}
    ;

factor
    ::= primary:p                     {: RESULT = p; :}// unary minus
    |   MINUS factor:f					{: RESULT = new UnaryMinusExpn(f); :}
    ;

primary
    ::= constant:c                            {: RESULT = c; :}                                // integer or boolean constant
    |   variable:v                             {: RESULT = v; :}                              // scalar, array variable or function call
    |   IDENT:name L_PAREN arguments:args R_PAREN         {: RESULT = new FunctionCallExpn(name, args); :}                            // function call
    |   L_PAREN expression:expn R_PAREN        {: RESULT = expn; :}                                  // parenthesized expression
    |   L_PAREN expression:cond QUESTION expression:ifTrue COLON expression:ifFalse R_PAREN {: RESULT = new ConditionalExpn(cond, ifTrue, ifFalse); :}    // conditional expression
    ;

constant
    ::= INTCONST:ic		{: RESULT = new IntConstExpn(ic); :}                    // integer constant
    |   TRUE			{: RESULT = new BoolConstExpn(true); :}                        // constant true
    |   FALSE         {: RESULT = new BoolConstExpn(false); :}              // constant false
    ;

variable
    ::= IDENT:id              {: RESULT = new IdentExpn(id); :}// scalar variable or function call
    |   IDENT:id L_SQUARE expression:expn R_SQUARE      {: RESULT = new SubsExpn(id, expn); :}         // element of 1-dimensional array
    |   IDENT:id L_SQUARE expression:expn1 COMMA expression:expn2 R_SQUARE  {: RESULT = new SubsExpn(id, expn1, expn2); :}              // element of 2-dimensional array;
    ;
